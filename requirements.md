The purpose of this project is to create pair of scripts that help provision IoT devices (e.g. ESP32) with unique client certificates.  
    
Proposed project file structure. The server/ca structure is copied from Jamie's excellent publication [OpenSSL Certificate Authority](https://jamielinux.com/docs/openssl-certificate-authority/index.html "OpenSSL Certificate Authority")  
```  
├── client
│   ├── pki_client_settings.json
│   └── pki_client.js 
├── server
│   ├── pki_server_settings.json
│   ├── pki_server.js
│   └── ca
│       ├── crl
│       │   └── ca.crl.pem
│       ├── newcerts
│       ├── private
│       │   ├── ca.key.pem
│       │   └── ...
│       ├── certs
│       │   ├── ca.key.pem
│       │   └── ...
│       ├── crlnumber (file)
│       ├── serial (file)
│       ├── index.txt
│       └── intermediate
│           ├── crl
│           │   └── intermediate.crl.pem
│           ├── csr
│           ├── newcerts
│           ├── private
│           │   ├── intermediate.key.pem
│           │   └── ...
│           ├── certs
│           │   ├── intermediate.cert.pem
│           │   └── ca-chain.cert.pem
│           ├── crlnumber (file)
│           ├── serial (file)
│           └── index.txt
├── img
├── docs
└── README.md
```  
  
Example bash scripts I wrote to create the root and intermediate CAs, generate server certificate and generate client certificate: [gist](https://gist.github.com/mharizanov/93c015329fcc91e30571d5093aee0b6e)  
  
The below flow represents roughly (WIP) the concept:  
![Flow diagram](https://raw.githubusercontent.com/mharizanov/node_pki/master/PKI_flow_diagram.png)

"ESP32" in the above diagram represents the device to be programmed.  
"laptop" in the above diagram represents the computer that is used to program and provision the "ESP32" devices.  
"cloud" represents a private virtual server on the cloud, accessible by domain name.  

There will be two distinct components that will run on the laptop and the cloud respectively (client-server architecture).  
  
The script running on the latop will be called "client".  
The script running on the cloud will be called "server".  
  
The solution will be based on creating own certificate authority (CA) using OpenSSL.  
There will be a root pair, then intermediate pair. The intermediate pair will be used to sign server and client certificates.  
  
### Requirements
The client will create a private key (RSA 2048) for the device to be provisioned.  
The client will create a CSR (signed with the private key that was generated in the previous requirement) that will be sent to the cloud script for signing and in return will expect a client certificate.  
The client will take as parameter the device MAC address.  
The MAC address provided as a parameter to the client will be used as CommonName field in the CSR.  
The client will generate a JSON request that will be sent to the server for processing.  
The CSR generated by the client will be packaged into the JSON request using base64 encoding.  
The JSON request will contain other parameters that will instruct the server on what is expected of it, for example "operation":"req_client_cert" that will instruct the server to use the passed CRS to return a client certificate.  
The client will timeout with error, if it cannot reach the server.  
..  
The server will run on configurable TCP port.  
The server will will receive API calls via JSON requests.  
The server will validate the JSON requrest.  
The server will process know JSON requests, e.g. such that contain known "operation":"XXXXXX".  
The server will process requests to sign CSRs.  
The server will process requests to revoke client certificates.  
The sever will store the generated client certificates in a file system.  
The server will store the generated client certificate's serial number in a text log file.
... wip
